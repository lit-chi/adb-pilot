import { Buffer } from 'node:buffer';
import ExtendedPublicKey from '../models/ExtendedPublicKey.js';
import { Duplex, Readable } from 'node:stream';
import PromiseDuplex from 'promise-duplex';
import Debug from 'debug';
import PromiseReadable from 'promise-readable';
import { type Stream } from 'node:stream';
export type CancellablePromise<T> = Promise<T> & {
    cancel: () => void;
};
/**
 * Missing from Deno ?
 */
export type BufferEncoding = Parameters<typeof Stream.PassThrough.prototype.write>[1];
export default class Utils {
    /**
     * concat buffer to fix deno typing errors.
     */
    static concatBuffer(buffs: Buffer[]): Buffer;
    /**
     * Takes a [`Stream`][node-stream] and reads everything it outputs until the stream ends. Then it resolves with the collected output. Convenient with `client.shell()`.
     *
     * @param stream The [`Stream`][node-stream] to read.
     * @returns All the output as a [`Buffer`][node-buffer]. Use `output.toString('utf-8')` to get a readable string from it.
     */
    static readAll(stream: Duplex): Promise<Buffer>;
    /**
     * Parses an Android-formatted mincrypt public key (e.g. `~/.android/adbkey.pub`).
     *
     * @param keyString The key String or [`Buffer`][node-buffer] to parse. Not a filename.
     * @returns The key as a [forge.pki](https://github.com/digitalbazaar/forge#rsa) public key. You may need [node-forge](https://github.com/digitalbazaar/forge) for complicated operations.
     */
    static parsePublicKey(keyString: string): Promise<ExtendedPublicKey>;
    /**
     * A delay promise
     *
     * @param ms time to wait im ms
     * @returns void
     */
    static delay(ms: number): CancellablePromise<void>;
    /**
     * Promise waiter for a Duplex to be readable
     *
     * @param duplex a vanilla Duplex of a PromiseDuplex
     * @param timeout do not wait more than timeout
     * @returns is the true is duplex is readable
     */
    static waitforReadable(duplex?: Duplex | PromiseDuplex<Duplex> | Readable | PromiseReadable<Readable>, timeout?: number, _debugCtxt?: string): Promise<boolean>;
    /**
     * Wait for a spesific text in the Duplex
     * all text will be concatened in a single string to dean with segments.
     *
     * @param duplex
     * @param expected regexp to match
     * @returns matched text
     */
    static waitforText(duplex: PromiseDuplex<Duplex>, expected: RegExp, timeout?: number): Promise<string>;
    static debug(name: string): Debug.Debugger;
}
//# sourceMappingURL=utils.d.ts.map