import Command from '../../command.js';
import ShellExecError from './ShellExecError.js';
export default class IpRouteCommand extends Command {
    constructor(connection, options) {
        super(connection, options);
    }
    async execute(...args) {
        super.sendCommand(['shell:ip', 'route', ...args].join(' ')); //  2>/dev/null
        await this.readOKAY();
        const data = await this.parser.readAll();
        return this.parseIpRoute(data.toString());
    }
    parseIpRoute(value) {
        if (value.startsWith('Error: ')) {
            throw new ShellExecError(`Sending command:\n${this.lastCommand}\n cause ${value.trim()}`);
        }
        // const value = await this.readValue();
        const lines = value.split(/[\r\n]+/g).filter(a => a);
        const result = [];
        for (const line of lines) {
            result.push(new IpRouteEntry(line));
        }
        return result;
    }
}
const ValidTypes = ['anycast', 'unicast', 'local', 'broadcast', 'multicast', 'throw', 'unreachable', 'prohibit', 'blackhole', 'nat'];
const ValidTypesSet = new Set(ValidTypes);
/**
 * unix route model
 * ROUTE := NODE_SPEC [ INFO_SPEC ]
 *
 * NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ]
 */
export class IpRouteEntry {
    constructor(line) {
        const words = line.split(' ').filter(a => a);
        if (ValidTypesSet.has(words[0])) {
            this.type = words.shift();
        }
        if (words[0] === 'default') {
            this.dest = words.shift();
        }
        else if (words[0].match(/^[0-9.]+(\/\d+)?$/)) {
            // IP v4
            this.dest = words.shift();
        }
        else if (words[0].match(/^[0-9a-f:]+(\/\d+)?$/)) {
            // IP v6
            this.dest = words.shift();
        }
        while (words.length) {
            const next = words.shift();
            const value = words.shift() || '';
            switch (next) {
                case 'dev':
                case 'via':
                case 'src':
                case 'tos':
                case 'mtu':
                case 'expires':
                    this[next] = value;
                    break;
                case 'metric':
                case 'hoplimit':
                    this[next] = Number(value);
                    break;
                case 'pref':
                case 'scope':
                case 'table':
                case 'proto':
                    if (value.match(/^\d+$/))
                        this[next] = Number(value);
                    else
                        this[next] = value;
                    break;
                default:
                    throw Error(`Failed to parse line:\n ${line}\n token: ${next} in ip route response, Fix me in ipRoute.ts`);
            }
        }
    }
    toString() {
        const out = [];
        for (const field of ['type', 'dest']) {
            const value = this[field];
            if (value)
                out.push(value);
        }
        for (const field of ['via', 'dev', 'table', 'expires', 'proto', 'scope', 'tos', 'src', 'metric', 'pref', 'mtu']) {
            if (this[field] || this[field] === 0) {
                out.push(field);
                out.push(String(this[field]));
            }
        }
        return out.join(' ');
    }
    clone() {
        return new IpRouteEntry(this.toString());
    }
}
//# sourceMappingURL=ipRoute.js.map