import Command from '../../command.js';
/**
 * usage: ps [-AadefLlnwZ] [-gG GROUP,] [-k FIELD,] [-o FIELD,] [-p PID,] [-t TTY,] [-uU USER,]
 *
 * List processes.
 *
 * Which processes to show (-gGuUpPt selections may be comma separated lists):
 *
 * -A  All                                 -a  Has terminal not session leader
 * -d  All but session leaders             -e  Synonym for -A
 * -g  In GROUPs                           -G  In real GROUPs (before sgid)
 * -p  PIDs (--pid)                        -P  Parent PIDs (--ppid)
 * -s  In session IDs                      -t  Attached to selected TTYs
 * -T  Show threads also                   -u  Owned by selected USERs
 * -U  Real USERs (before suid)
 *
 * Output modifiers:
 *
 * -k  Sort FIELDs (-FIELD to reverse)     -M  Measure/pad future field widths
 * -n  Show numeric USER and GROUP         -w  Wide output (don't truncate fields)
 *
 * Which FIELDs to show. (-o HELP for list, default = -o PID,TTY,TIME,CMD)
 *
 * -f  Full listing (-o USER:12=UID,PID,PPID,C,STIME,TTY,TIME,ARGS=CMD)
 * -l  Long listing (-o F,S,UID,PID,PPID,C,PRI,NI,ADDR,SZ,WCHAN,TTY,TIME,CMD)
 * -o  Output FIELDs instead of defaults, each with optional :size and =title
 * -O  Add FIELDS to defaults
 * -Z  Include LABEL
 */
export default class PsCommand extends Command {
    async execute(...args) {
        if (!args.length) {
            this.sendCommand(`shell:ps`); //  2>/dev/null
        }
        else {
            this.sendCommand(`shell:ps ${args.join(' ')}`); //  2>/dev/null
        }
        await this.readOKAY();
        const data = await this.parser.readAll();
        return this._parsePs(data.toString());
    }
    _parsePs(value) {
        const lines = value.split(/[\r\n]+/g);
        const titles = (lines.shift() || '').trim();
        const cols = titles.split(/\s+/g);
        const result = [];
        for (const line of lines) {
            if (!line)
                continue;
            const ps = {};
            let p = 0;
            const last = cols.length - 1;
            for (let i = 0; i < last; i++) {
                const p2 = line.indexOf(' ', p);
                ps[cols[i]] = line.substring(p, p2);
                p = p2 + 1;
                while (line[p] == ' ')
                    p++;
            }
            ps[cols[last]] = line.substring(p);
            result.push(ps);
        }
        return result;
    }
}
//# sourceMappingURL=ps.js.map