import { EventEmitter } from 'node:events';
import { Buffer } from 'node:buffer';
import DeviceClient from '../../DeviceClient.js';
/**
 * Application binary interface known CPU
 */
export type ABI_CPU = 'arm64-v8a' | 'armeabi-v7a' | 'x86' | 'x86_64';
export interface MinicapOptions {
    /**
     * dimention formated as `{RealWidth}x{RealHeight}@{VirtualWidth}x{VirtualHeight}/{Orientation}`
     */
    dimention: string;
}
/**
 * enforce EventEmitter typing
 */
interface IEmissions {
    data: (data: Buffer) => void;
    error: (error: Error) => void;
    disconnect: (cause: string) => void;
}
export default class Minicap extends EventEmitter {
    private client;
    private config;
    private videoSocket;
    private minicapServer;
    /** 0=255 */
    private _version;
    private _pid;
    private _realWidth;
    private _realHigth;
    private _virtualWidth;
    private _virtualHigth;
    private _orientation;
    private _bitflags;
    private _firstFrame;
    private setVersion;
    private setPid;
    private setRealWidth;
    private setRealHigth;
    private setVirtualWidth;
    private setVirtualHigth;
    private setOrientation;
    private setBitflags;
    private setFirstFrame;
    /**
     * closed had been call stop all new activity
     */
    private closed;
    constructor(client: DeviceClient, config?: Partial<MinicapOptions>);
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    get version(): Promise<number>;
    get pid(): Promise<number>;
    get realwidth(): Promise<number>;
    get realheight(): Promise<number>;
    get vitualWidth(): Promise<number>;
    get vitualHeight(): Promise<number>;
    /**
     * return virtual width
     */
    get width(): Promise<number>;
    /**
     * return virtual heigth
     */
    get height(): Promise<number>;
    get orientation(): Promise<number>;
    /**
     * return full bitflags, QuickDumb, QuickAlwaysUpright and QuickTear can be used.
     */
    get bitflags(): Promise<number>;
    /**
     * Frames will get sent even if there are no changes from the previous frame. Informative, doesn't require any actions on your part. You can limit the capture rate by reading frame data slower in your own code if you wish.
     */
    get QuickDumb(): Promise<boolean>;
    /**
     * 	The frame will always be in upright orientation regardless of the device orientation. This needs to be taken into account when rendering the image.
     */
    get QuickAlwaysUpright(): Promise<boolean>;
    /**
     * Frame tear might be visible. Informative, no action required. Neither of our current two methods exhibit this behavior.
     */
    get QuickTear(): Promise<boolean>;
    /**
     * Promise to the first emited frame
     * can be used to unsure that scrcpy propery start
     */
    get firstFrame(): Promise<void>;
    /**
     *
     * @returns resolved once localabstract:minicap is connected
     */
    start(): Promise<this>;
    private startStream;
    /**
     * closed all socket and emit disconnect in if socket closed
     * @returns true if videoSocket or minicapServer get closed
     */
    stop(cause?: string): boolean;
    isRunning(): boolean;
}
export {};
//# sourceMappingURL=Minicap.d.ts.map