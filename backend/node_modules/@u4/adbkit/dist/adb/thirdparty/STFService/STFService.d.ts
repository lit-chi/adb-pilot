import { EventEmitter } from 'node:events';
import { Duplex } from 'node:stream';
import DeviceClient from '../../DeviceClient.js';
import PromiseDuplex from 'promise-duplex';
import * as STF from './STFServiceModel.js';
interface IEmissions {
    airplaneMode: (data: STF.AirplaneModeEvent) => void;
    battery: (data: STF.BatteryEvent) => void;
    connectivity: (data: STF.ConnectivityEvent) => void;
    phoneState: (data: STF.PhoneStateEvent) => void;
    rotation: (data: STF.RotationEvent) => void;
    browerPackage: (data: STF.BrowserPackageEvent) => void;
    error: (data: Error) => void;
    disconnect: () => void;
}
export interface STFServiceOptions {
    /**
     * calls timeout default is 15000 ms
     */
    timeout: number;
    /**
     * do not install the APK, if you use a custom apk
     */
    noInstall: boolean;
}
export default class STFService extends EventEmitter {
    private client;
    private config;
    private servicesSocket;
    private protoSrv;
    private _maxContact;
    private _width;
    private _height;
    private _maxPressure;
    private setMaxContact;
    private setWidth;
    private setHeight;
    private setMaxPressure;
    constructor(client: DeviceClient, options?: Partial<STFServiceOptions>);
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    get maxContact(): Promise<number>;
    get width(): Promise<number>;
    get height(): Promise<number>;
    get maxPressure(): Promise<number>;
    /**
     * find the APK and install it
     */
    private installApk;
    private _cachedApkPath;
    /**
     *
     * @returns get agent setup path
     */
    private getApkPath;
    /**
     * get the current installed Agent version number
     * @returns 'MISSING' if not installed, 'OK' if expected, 'MISMATCH' if version differ
     */
    private checkVersion;
    /**
      * start agent
      */
    private startAgent;
    /**
     * start long running service and keep the duplex opened
     */
    private startService;
    /**
     * uninstall the service
     */
    uninstall(): Promise<boolean>;
    start(): Promise<this>;
    private _minitouchagent;
    /**
     * get minitouch duplex, if not connected open connexion
     */
    getMinitouchSocket(): Promise<PromiseDuplex<Duplex>>;
    private _agentSocket;
    getAgentSocket(): Promise<PromiseDuplex<Duplex>>;
    private startServiceStream;
    /**
     * RCV banne:
     * v 1
     * ^ %d %d %d %d DEFAULT_MAX_CONTACTS, width, height, DEFAULT_MAX_PRESSURE;
     * @param socket
     */
    private startMinitouchStream;
    private startAgentStream;
    /**
     * esponce callback hooks
     */
    private responseHook;
    /**
     * request id counter [1..0xFFFFFF]
     */
    private reqCnt;
    /**
     * Generic method to push message to service
     */
    private pushService;
    /**
     * Generic method to push message to agent
     */
    private pushAgent;
    getAccounts(type?: string): Promise<STF.GetAccountsResponse>;
    getBrowsers(req?: STF.GetBrowsersRequest): Promise<STF.GetBrowsersResponse>;
    getClipboard(type?: 1): Promise<STF.GetClipboardResponse>;
    getDisplay(id?: number): Promise<STF.GetDisplayResponse>;
    getProperties(properties: string[]): Promise<STF.GetPropertiesResponse>;
    getRingerMode(req?: STF.GetRingerModeRequest): Promise<STF.GetRingerModeResponse>;
    getSdStatus(req?: STF.GetSdStatusRequest): Promise<STF.GetSdStatusResponse>;
    getWifiStatus(req?: STF.GetWifiStatusRequest): Promise<STF.GetWifiStatusResponse>;
    getBluetoothStatus(req?: STF.GetBluetoothStatusRequest): Promise<STF.GetBluetoothStatusResponse>;
    getRootStatus(req?: STF.GetRootStatusRequest): Promise<STF.GetRootStatusResponse>;
    setClipboard(req: STF.SetClipboardRequest): Promise<STF.SetClipboardResponse>;
    setKeyguardState(req: STF.SetKeyguardStateRequest): Promise<STF.SetKeyguardStateResponse>;
    setRingerMode(req: STF.SetRingerModeRequest): Promise<STF.SetRingerModeResponse>;
    setRotationRequest(req: STF.SetRotationRequest): Promise<void>;
    setWakeLock(req: STF.SetWakeLockRequest): Promise<STF.GetWifiStatusResponse>;
    setWifiEnabledRequest(req: STF.SetWifiEnabledRequest): Promise<STF.SetWifiEnabledResponse>;
    setBluetoothEnabledRequest(req: STF.SetBluetoothEnabledRequest): Promise<STF.SetBluetoothEnabledResponse>;
    setMasterMute(req: STF.SetMasterMuteRequest): Promise<STF.SetMasterMuteResponse>;
    doKeyEvent(req: STF.KeyEventRequest): Promise<number>;
    doType(req: STF.DoTypeRequest): Promise<number>;
    doWake(req: STF.DoWakeRequest): Promise<number>;
    setRotation(req: STF.SetRotationRequest): Promise<number>;
    /**
     * Send commit minitouch events
     */
    commit(): Promise<number>;
    /**
     * Send move minitouch events
     */
    move(x: number, y: number, contact?: 0 | 1, pressure?: number): Promise<number>;
    /**
     * Send press down minitouch events
     */
    down(x: number, y: number, contact?: 0 | 1, pressure?: number): Promise<number>;
    /**
     * Send press up minitouch events
     */
    up(contact?: 0 | 1): Promise<number>;
    /**
     * Send move + commit minitouch events
     */
    moveCommit(x: number, y: number, contact?: 0 | 1, pressure?: number): Promise<number>;
    /**
     * Send press down + commit minitouch events
     */
    downCommit(x: number, y: number, contact?: 0 | 1, pressure?: number): Promise<number>;
    /**
     * Send press up + commit minitouch events
     */
    upCommit(contact?: 0 | 1): Promise<number>;
    /**
     * Send wait instruction minitouch events
     */
    wait(time: number): Promise<number>;
    /**
     * stop the service
     */
    stop(): boolean;
    isRunning(): boolean;
}
export {};
//# sourceMappingURL=STFService.d.ts.map