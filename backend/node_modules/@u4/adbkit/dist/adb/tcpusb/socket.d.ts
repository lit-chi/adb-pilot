import EventEmitter from 'node:events';
import { Buffer } from 'node:buffer';
import Packet from './packet.js';
import Client from '../client.js';
import Net from 'node:net';
import SocketOptions from '../../models/SocketOptions.js';
export declare class AuthError extends Error {
    constructor(message: string);
}
export declare class UnauthorizedError extends Error {
    constructor();
}
/**
 * enforce EventEmitter typing
 */
interface IEmissions {
    end: (serv: boolean) => void;
    userActivity: (packet: Packet) => void;
    error: (data: Error) => void;
}
export default class Socket extends EventEmitter {
    private readonly client;
    private readonly serial;
    private socket;
    private options;
    static AuthError: typeof AuthError;
    static UnauthorizedError: typeof UnauthorizedError;
    private ended;
    private reader;
    private authorized;
    private syncToken;
    private remoteId;
    private services;
    private remoteAddress?;
    private token?;
    private signature?;
    version: number;
    maxPayload: number;
    constructor(client: Client, serial: string, socket: Net.Socket, options?: SocketOptions);
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    end(): Socket;
    private _error;
    private _handle;
    private _handleSyncPacket;
    private _handleConnectionPacket;
    private _handleAuthPacket;
    private _handleOpenPacket;
    private _forwardServicePacket;
    write(chunk: Buffer | string): boolean;
    private _createToken;
    private _skipNull;
    private _deviceId;
}
export {};
//# sourceMappingURL=socket.d.ts.map