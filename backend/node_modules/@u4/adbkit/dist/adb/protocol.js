import { Buffer } from 'node:buffer';
import Utils from './utils.js';
/**
 * adb Protocol is a 4 byte prefixed message.
 * the 4 fisrt byte can be on of the 10 predefined Code, of a 4-hexa string indicating the message len.
 */
class Protocol {
    /**
     * parse a 4 char string
     */
    static decodeLength(length) {
        return parseInt(length, 16);
    }
    /**
     *
     * @param length message len
     * @returns message len as a 4 char string
     */
    static encodeLength(length) {
        return length.toString(16).padStart(4, '0').toUpperCase();
    }
    /**
     * prefix a chunk with it's len stored in a 4 char hexa string, so data len can not exceed 0Xffff
     * @param data string or buffer to send.
     * @returns data as a Buffer prefixed by a 4 char Base16 length chunk
     */
    static encodeData(data) {
        if (!Buffer.isBuffer(data)) {
            data = Buffer.from(data);
        }
        const len = Protocol.encodeLength(data.length);
        // return Buffer.concat([Buffer.from(len), data]);
        return Utils.concatBuffer([Buffer.from(len), data]);
    }
}
Protocol.OKAY = 'OKAY';
Protocol.FAIL = 'FAIL';
Protocol.STAT = 'STAT';
Protocol.STA2 = 'STA2';
Protocol.LIST = 'LIST';
Protocol.LIS2 = 'LIS2';
Protocol.DENT = 'DENT';
Protocol.DNT2 = 'DNT2';
Protocol.RECV = 'RECV';
Protocol.DATA = 'DATA';
Protocol.DONE = 'DONE';
Protocol.SEND = 'SEND';
Protocol.QUIT = 'QUIT';
Protocol.bOKAY = Buffer.from(Protocol.OKAY);
Protocol.bFAIL = Buffer.from(Protocol.FAIL);
Protocol.bSTAT = Buffer.from(Protocol.STAT);
Protocol.bSTA2 = Buffer.from(Protocol.STA2);
Protocol.bLIST = Buffer.from(Protocol.LIST);
Protocol.bLIS2 = Buffer.from(Protocol.LIS2);
Protocol.bDENT = Buffer.from(Protocol.DENT);
Protocol.bRECV = Buffer.from(Protocol.RECV);
Protocol.bDATA = Buffer.from(Protocol.DATA);
Protocol.bDONE = Buffer.from(Protocol.DONE);
Protocol.bSEND = Buffer.from(Protocol.SEND);
Protocol.bQUIT = Buffer.from(Protocol.QUIT);
export default Protocol;
//# sourceMappingURL=protocol.js.map