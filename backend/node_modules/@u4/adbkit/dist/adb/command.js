import Protocol from './protocol.js';
import Utils from './utils.js';
const debug = Utils.debug('adb:command');
const RE_SQUOT = /'/g;
const RE_ESCAPE = /([$`\\!"])/g;
export default class Command {
    get lastCommand() {
        return this.lastCmd || '';
    }
    constructor(connection, options = {}) {
        this.connection = connection;
        this.lastCmd = '';
        this.options = { sudo: false, ...options };
    }
    get parser() {
        return this.connection.parser;
    }
    /**
     * encode message and send it to ADB socket
     * @returns byte write count
     */
    _send(data) {
        this.parser.lastMessage = data;
        const encoded = Protocol.encodeData(data);
        if (debug.enabled) {
            debug(`Send '${encoded}'`);
        }
        return this.connection.write(encoded);
    }
    escape(arg) {
        switch (typeof arg) {
            case 'number':
                return arg;
            default:
                return `'${arg.toString().replace(RE_SQUOT, "'\"'\"'")}'`;
        }
    }
    escapeCompat(arg) {
        switch (typeof arg) {
            case 'number':
                return arg;
            default:
                return `"${arg.toString().replace(RE_ESCAPE, '\\$1')}"`;
        }
    }
    /**
     * called once per command, only affect shell based command.
     * @returns sent data
     */
    async sendCommand(data) {
        if (this.options.sudo) {
            if (data.startsWith('shell:')) {
                data = 'shell:su -c \'' + data.substring(6).replace(/'/g, "\\'") + '\'';
            }
            else if (data.startsWith('exec:')) {
                data = 'exec:su -c \'' + data.substring(5).replace(/'/g, "\\'") + '\'';
            }
        }
        this.lastCmd = data;
        await this._send(data);
        return data;
    }
    /**
     * most common action: read for Okey
     */
    async readOKAY() {
        await this.parser.readCode(Protocol.OKAY);
    }
}
//# sourceMappingURL=command.js.map