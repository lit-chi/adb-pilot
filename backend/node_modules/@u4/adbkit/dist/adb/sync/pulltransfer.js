import { Stream } from 'node:stream';
/**
 * `PullTransfer` is a [`Stream`][node-stream]. Use [`fs.createWriteStream()`][node-fs] to pipe the stream to a file if necessary.
 */
export default class PullTransfer extends Stream.PassThrough {
    constructor() {
        super(...arguments);
        this.stats = {
            bytesTransferred: 0,
        };
    }
    /**
     * Cancels the transfer by ending the connection. Can be useful for reading endless streams of data, such as `/dev/urandom` or `/dev/zero`, perhaps for benchmarking use. Note that you must create a new sync connection if you wish to continue using the sync service.
     * @returns The pullTransfer instance.
     */
    cancel() {
        return this.emit('cancel');
    }
    write(chunk, encoding, callback) {
        this.stats.bytesTransferred += chunk.length;
        this.emit('progress', this.stats);
        if (typeof encoding === 'function') {
            return super.write(chunk, encoding);
        }
        return super.write(chunk, encoding || "utf8", callback);
    }
    promiseWrite(chunk, encoding) {
        this.stats.bytesTransferred += chunk.length;
        this.emit('progress', this.stats);
        return new Promise((accept, reject) => {
            super.write(chunk, encoding || "utf8", (err) => {
                if (err)
                    reject(err);
                else
                    accept();
            });
        });
    }
    /**
     * get end notification using Promise
     */
    waitForEnd() {
        if (!this.waitForEndPromise) {
            if (this.closed) {
                this.waitForEndPromise = Promise.resolve();
            }
            else {
                this.waitForEndPromise = new Promise((resolve, reject) => {
                    const unReg = () => {
                        this.off('end', onEnd);
                        this.off('error', onError);
                    };
                    const onError = (e) => { unReg(); reject(e); };
                    const onEnd = () => (unReg(), resolve());
                    this.on('end', onEnd);
                    this.on('error', onError);
                });
            }
        }
        return this.waitForEndPromise;
    }
}
//# sourceMappingURL=pulltransfer.js.map