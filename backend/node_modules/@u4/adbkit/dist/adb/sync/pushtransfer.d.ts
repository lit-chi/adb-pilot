import EventEmitter from 'node:events';
/**
 * enforce EventEmitter typing
 */
interface IEmissions {
    /**
     * Emitted on error.
     */
    end: () => void;
    cancel: () => void;
    /**
     * **(stats)** Emitted when a chunk has been flushed to the ADB connection.
     * @param stats An object with the following stats about the transfer:
     */
    progress: (stats: {
        bytesTransferred: number;
    }) => void;
    /**
     * Emitted when the transfer has successfully completed.
     */
    error: (data: Error) => void;
}
/**
 * A simple EventEmitter, mainly for keeping track of the progress.
 */
export default class PushTransfer extends EventEmitter {
    private stack;
    stats: {
        bytesTransferred: number;
    };
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    /**
     * Cancels the transfer by ending both the stream that is being pushed and the sync connection. This will most likely end up creating a broken file on your device. **Use at your own risk.** Also note that you must create a new sync connection if you wish to continue using the sync service.
     * @returns The pushTransfer instance.
     */
    cancel(): boolean;
    push(byteCount: number): number;
    pop(): boolean;
    private done;
    end(): boolean;
    private waitForEndPromise?;
    /**
     * get end notification using Promise
     */
    waitForEnd(): Promise<void>;
}
export {};
//# sourceMappingURL=pushtransfer.d.ts.map