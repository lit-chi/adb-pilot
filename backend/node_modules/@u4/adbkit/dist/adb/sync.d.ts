import EventEmitter from 'node:events';
import { Readable } from 'node:stream';
import Stats from './sync/stats.js';
import Entry from './sync/entry.js';
import PushTransfer from './sync/pushtransfer.js';
import PullTransfer from './sync/pulltransfer.js';
import Connection from './connection.js';
import Stats64 from './sync/stats64.js';
import Entry64 from './sync/entry64.js';
export interface ENOENT extends Error {
    errno: 34;
    code: 'ENOENT';
    path: string;
}
/**
 * error code from STA2
 */
export declare const AdbSyncStatErrorCodeMap: {
    readonly SUCCESS: 0;
    readonly EACCES: 13;
    readonly EEXIST: 17;
    readonly EFAULT: 14;
    readonly EFBIG: 27;
    readonly EINTR: 4;
    readonly EINVAL: 22;
    readonly EIO: 5;
    readonly EISDIR: 21;
    readonly ELOOP: 40;
    readonly EMFILE: 24;
    readonly ENAMETOOLONG: 36;
    readonly ENFILE: 23;
    readonly ENOENT: 2;
    readonly ENOMEM: 12;
    readonly ENOSPC: 28;
    readonly ENOTDIR: 20;
    readonly EOVERFLOW: 75;
    readonly EPERM: 1;
    readonly EROFS: 30;
    readonly ETXTBSY: 26;
};
export type AdbSyncStatErrorCode = typeof AdbSyncStatErrorCodeMap[keyof typeof AdbSyncStatErrorCodeMap];
/**
 * enforce EventEmitter typing
 */
interface IEmissions {
    error: (data: Error) => void;
}
export default class Sync extends EventEmitter {
    private connection;
    private parser;
    /**
     * get a temp file path
     * @param path filename
     * @returns full path on android devices
     */
    static temp(path: string): string;
    constructor(connection: Connection);
    on: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    off: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    once: <K extends keyof IEmissions>(event: K, listener: IEmissions[K]) => this;
    emit: <K extends keyof IEmissions>(event: K, ...args: Parameters<IEmissions[K]>) => boolean;
    /**
     * Retrieves information about the given path.
     * @param path The path.
     * @returns An [`fs.Stats`][node-fs-stats] instance. While the `stats.is*` methods are available, only the following properties are supported:
     * *   **mode** The raw mode.
     * *   **size** The file size.
     * *   **mtime** The time of last modification as a `Date`.
     */
    stat(path: string): Promise<Stats>;
    stat64(path: string): Promise<Stats64>;
    /**
     * Retrieves a list of directory entries (e.g. files) in the given path, not including the `.` and `..` entries, just like [`fs.readdir`][node-fs]. If given a non-directory path, no entries are returned.
     *
     * @param path The path.
     * @returns An `Array` of [`fs.Stats`][node-fs-stats]-compatible instances. While the `stats.is*` methods are available, only the following properties are supported (in addition to the `name` field which contains the filename):
     *  *   **name** The filename.
     *  *   **mode** The raw mode.
     *  *   **size** The file size.
     *  *   **mtime** The time of last modification as a `Date`.
     */
    readdir(path: string): Promise<Array<Entry>>;
    readdir64(path: string): Promise<Array<Entry64>>;
    /**
     * Attempts to identify `contents` and calls the appropriate `push*` method for it.
     *
     * @param contents When `String`, treated as a local file path and forwarded to `sync.pushFile()`. Otherwise, treated as a [`Stream`][node-stream] and forwarded to `sync.pushStream()`.
     * @param path The path to push to.
     * @param mode Optional. The mode of the file. Defaults to `0644`.
     * @returns A `PushTransfer` instance. See below for details.
     */
    push(contents: string | Readable, path: string, mode?: number, streamName?: string): Promise<PushTransfer>;
    /**
     * Pushes a local file to the given path. Note that the path must be writable by the ADB user (usually `shell`). When in doubt, use `'/data/local/tmp'` with an appropriate filename.
     *
     * @param file The local file path.
     * @param path See `sync.push()` for details.
     * @param mode See `sync.push()` for details.
     * @returns See `sync.push()` for details.
     */
    pushFile(file: string, path: string, mode?: number): Promise<PushTransfer>;
    /**
     * Pushes a [`Stream`][node-stream] to the given path. Note that the path must be writable by the ADB user (usually `shell`). When in doubt, use `'/data/local/tmp'` with an appropriate filename.
     *
     * @param stream The readable stream.
     * @param path See `sync.push()` for details.
     * @param mode See `sync.push()` for details.
     * @returns See `sync.push()` for details.
     */
    pushStream(stream: Readable, path: string, mode?: number, streamName?: string): Promise<PushTransfer>;
    /**
     * Pulls a file from the device as a `PullTransfer` [`Stream`][node-stream].
     * @param path The path to pull from.
     * @returns A `PullTransfer` instance. See below for details.
     */
    pull(path: string): Promise<PullTransfer>;
    /**
     * Closes the Sync connection, allowing Node to quit (assuming nothing else is keeping it alive, of course).
     * @returns Returns: The sync instance.
     */
    end(): Sync;
    /**
     * A simple helper method for creating appropriate temporary filenames for pushing files. This is essentially the same as taking the basename of the file and appending it to `'/data/local/tmp/'`.
     *
     * @param path The path of the file.
     * @returns An appropriate temporary file path.
     */
    tempFile(path: string): string;
    private _writeData;
    private readData;
    /**
     *
     * @param cmd
     * @param length
     * @returns byte write count
     */
    private sendCommandWithLength;
    /**
     *
     * @param cmd
     * @param arg
     * @returns byte write count
     */
    private sendCommandWithArg;
    private enoent;
}
export {};
//# sourceMappingURL=sync.d.ts.map