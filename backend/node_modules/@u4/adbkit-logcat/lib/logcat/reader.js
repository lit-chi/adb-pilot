"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const binary_1 = __importDefault(require("./parser/binary"));
const transform_1 = __importDefault(require("./transform"));
const priority_1 = __importDefault(require("./priority"));
const ANY = '*';
const defaults = {
    format: 'binary',
    fixLineFeeds: true,
    priority: priority_1.default.DEBUG
};
class Reader extends events_1.EventEmitter {
    constructor(options = {}) {
        super(options);
        this.filters = {
            all: -1,
            tags: {}
        };
        this.options = { ...options, ...defaults };
        if (this.options.format !== 'binary') {
            throw new Error(`Unsupported format '${this.options.format}'`);
        }
        this.parser = new binary_1.default();
        this.stream = null;
    }
    exclude(tag) {
        if (tag === Reader.ANY) {
            return this.excludeAll();
        }
        this.filters.tags[tag] = priority_1.default.SILENT;
        return this;
    }
    excludeAll() {
        this.filters.all = priority_1.default.SILENT;
        return this;
    }
    include(tag, priority) {
        if (typeof priority === 'undefined') {
            priority = this.options.priority;
        }
        if (tag === Reader.ANY) {
            return this.includeAll(priority);
        }
        this.filters.tags[tag] = this._priority(priority);
        return this;
    }
    includeAll(priority) {
        if (typeof priority === 'undefined') {
            priority = this.options.priority;
        }
        this.filters.all = this._priority(priority);
        return this;
    }
    resetFilters() {
        this.filters.all = -1;
        this.filters.tags = {};
        return this;
    }
    _hook() {
        if (!this.stream)
            throw Error('Stream is not connected');
        if (this.options.fixLineFeeds) {
            const transform = this.stream.pipe(new transform_1.default());
            transform.on('data', data => {
                this.parser.parse(data);
            });
        }
        else {
            if (this.stream)
                this.stream.on('data', data => this.parser.parse(data));
        }
        if (this.stream) {
            this.stream.on('error', err => this.emit('error', err));
            this.stream.on('end', () => this.emit('end'));
            this.stream.on('finish', () => this.emit('finish'));
        }
        this.parser.on('entry', entry => {
            if (this._filter(entry)) {
                this.emit('entry', entry);
            }
        });
        this.parser.on('error', err => {
            this.emit('error', err);
        });
    }
    _filter(entry) {
        const wanted = (entry.tag in this.filters.tags)
            ? this.filters.tags[entry.tag]
            : this.filters.all;
        return entry.priority >= wanted;
    }
    _priority(priority) {
        return typeof priority === 'number' ? priority : priority_1.default.fromName(priority);
    }
    connect(stream) {
        this.stream = stream;
        this._hook();
        return this;
    }
    end() {
        if (this.stream)
            this.stream.end();
        return this;
    }
}
exports.default = Reader;
Reader.ANY = ANY;
